{"items": [{"owner": {"account_id": 4414299, "reputation": 3875, "user_id": 3596337, "user_type": "registered", "accept_rate": 62, "profile_image": "https://www.gravatar.com/avatar/e7077a19bac20bf5bc1ffb6e2c71039a?s=256&d=identicon&r=PG&f=y&so-version=2", "display_name": "keiv.fly", "link": "https://stackoverflow.com/users/3596337/keiv-fly"}, "is_accepted": true, "score": 49, "last_activity_date": 1660662401, "last_edit_date": 1660662401, "creation_date": 1645376234, "answer_id": 71196662, "question_id": 71196661, "content_license": "CC BY-SA 4.0", "body": "<p>The right function name is <code>.unique()</code></p>\n<pre><code>import polars as pl\ndf = pl.DataFrame({&quot;a&quot;:[1,1,2], &quot;b&quot;:[2,2,3], &quot;c&quot;:[1,2,3]})\ndf.unique(subset=[&quot;a&quot;,&quot;b&quot;])\n</code></pre>\n<p>And this delivers the right output:</p>\n<pre><code>shape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2   \u2506 1   \u2502\n\u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u2524\n\u2502 2   \u2506 3   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n"}, {"owner": {"account_id": 9013269, "reputation": 13413, "user_id": 6717054, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/72a7bcb06a087a25530bcbab56c2024f?s=256&d=identicon&r=PG", "display_name": "ritchie46", "link": "https://stackoverflow.com/users/6717054/ritchie46"}, "is_accepted": true, "score": 42, "last_activity_date": 1648542042, "creation_date": 1648542042, "answer_id": 71658695, "question_id": 71654966, "content_license": "CC BY-SA 4.0", "body": "<p>There are different <code>append</code> strategies depending on your needs.</p>\n<pre class=\"lang-py prettyprint-override\"><code>df1 = pl.DataFrame({&quot;a&quot;: [1], &quot;b&quot;: [2], &quot;c&quot;: [3]})\ndf2 = pl.DataFrame({&quot;a&quot;: [4], &quot;b&quot;: [5], &quot;c&quot;: [6]})\n\n\n# new memory slab\nnew_df = pl.concat([df1, df2], rechunk=True)\n\n# append free (no memory copy)\nnew_df = df1.vstack(df2)\n\n# try to append in place\ndf1.extend(df2)\n</code></pre>\n<p>To understand the differences, it is important to understand polars memory is immutable <code>iff</code> it has any copy.</p>\n<p>Copies in polars are free, because it only increments a reference count of the backing memory buffer instead of copying the data itself.</p>\n<p>However, if a memory buffer has no copies yet, e.g. the <code>refcount == 1</code>, we <strong>can</strong> mutate polars memory.</p>\n<p>Knowing this background there are the following ways to append data:</p>\n<ul>\n<li><code>concat</code> -&gt; concatenate all given <code>DataFrames</code>. This is sort of a linked list of <code>DataFrames</code>. If you pass <code>rechunk=True</code>, all memory will be reallocated to contiguous chunks.</li>\n<li><code>vstack</code> -&gt; Adds the data from <code>other</code> to <code>DataFrame</code> by incrementing a refcount. This is super cheap. It is recommended to call rechunk after many <code>vstacks</code>. Or simply use <code>pl.concat</code>.</li>\n<li><code>extend</code> This operation copies data. It tries to copy data from other to <code>DataFrame</code>. If however the <code>refcount</code> of <code>DataFrame</code> is larger than <code>1</code>. A new buffer of memory is allocated to hold both  <code>DataFrames</code>.</li>\n</ul>\n"}, {"owner": {"user_type": "does_not_exist", "display_name": "user18559875"}, "is_accepted": true, "score": 42, "last_activity_date": 1721556631, "last_edit_date": 1721556631, "creation_date": 1649201584, "answer_id": 71759536, "question_id": 71759316, "content_license": "CC BY-SA 4.0", "body": "<p>The easiest way to convert strings to Date/Datetime is to use Polars' own functions:</p>\n<ul>\n<li><a href=\"https://docs.pola.rs/api/python/stable/reference/expressions/api/polars.Expr.str.to_date.html\" rel=\"nofollow noreferrer\"><code>.str.to_date()</code></a></li>\n<li><a href=\"https://docs.pola.rs/api/python/stable/reference/expressions/api/polars.Expr.str.to_datetime.html\" rel=\"nofollow noreferrer\"><code>.str.to_datetime()</code></a></li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code>df.with_columns( \n    pl.col(&quot;event_date&quot;).str.to_datetime(&quot;%d %B %Y&quot;)\n)\n</code></pre>\n<pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 id  \u2506 event_date          \u2502\n\u2502 --- \u2506 ---                 \u2502\n\u2502 i64 \u2506 datetime[\u03bcs]        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2020-07-27 00:00:00 \u2502\n\u2502 2   \u2506 2020-12-31 00:00:00 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>The <a href=\"https://docs.pola.rs/api/python/stable/reference/expressions/temporal.html\" rel=\"nofollow noreferrer\">Temporal</a> section of the docs shows the supported functions in the <code>.dt</code> namespace.</p>\n<p>In the case of your second example, there is a dedicated quarter expression:</p>\n<ul>\n<li><a href=\"https://docs.pola.rs/api/python/stable/reference/expressions/api/polars.Expr.dt.quarter.html#polars.Expr.dt.quarter\" rel=\"nofollow noreferrer\"><code>.dt.quarter()</code></a></li>\n</ul>\n<pre class=\"lang-py prettyprint-override\"><code>df = df.with_columns( \n    pl.col(&quot;event_date&quot;).str.to_datetime(&quot;%d %B %Y&quot;)\n).with_columns(\n    pl.col(&quot;event_date&quot;).dt.quarter().alias(&quot;quarter&quot;)\n)\n</code></pre>\n<pre><code>shape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 id  \u2506 event_date          \u2506 quarter \u2502\n\u2502 --- \u2506 ---                 \u2506 ---     \u2502\n\u2502 i64 \u2506 datetime[\u03bcs]        \u2506 i8      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2020-07-27 00:00:00 \u2506 3       \u2502\n\u2502 2   \u2506 2020-12-31 00:00:00 \u2506 4       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n"}, {"owner": {"user_type": "does_not_exist", "display_name": "user18263465"}, "is_accepted": true, "score": 41, "last_activity_date": 1721470530, "last_edit_date": 1721470530, "creation_date": 1646326009, "answer_id": 71340745, "question_id": 71340260, "content_license": "CC BY-SA 4.0", "body": "<p>Use <a href=\"https://docs.pola.rs/api/python/stable/reference/expressions/api/polars.lit.html\" rel=\"nofollow noreferrer\"><code>polars.lit</code></a></p>\n<pre class=\"lang-py prettyprint-override\"><code>import polars as pl\n\nversion = 6\ndf = df.with_columns(pl.lit(version).alias('VERSION'))\n</code></pre>\n"}, {"owner": {"user_type": "does_not_exist", "display_name": "user18559875"}, "is_accepted": true, "score": 33, "last_activity_date": 1721470485, "last_edit_date": 1721470485, "creation_date": 1649807699, "answer_id": 71850319, "question_id": 71850031, "content_license": "CC BY-SA 4.0", "body": "<p>You were close.</p>\n<pre class=\"lang-py prettyprint-override\"><code>df.filter(~pl.col('fruits').is_in(exclude_fruit))\n</code></pre>\n<pre><code>shape: (3, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 A   \u2506 fruits \u2506 B   \u2506 cars   \u2506 optional \u2502\n\u2502 --- \u2506 ---    \u2506 --- \u2506 ---    \u2506 ---      \u2502\n\u2502 i64 \u2506 str    \u2506 i64 \u2506 str    \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 banana \u2506 5   \u2506 beetle \u2506 28       \u2502\n\u2502 2   \u2506 banana \u2506 4   \u2506 audi   \u2506 300      \u2502\n\u2502 5   \u2506 banana \u2506 1   \u2506 beetle \u2506 -30      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n"}, {"owner": {"account_id": 12582771, "reputation": 575, "user_id": 9152851, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f92f9c74f60cf6bab7c94243b42b6ed1?s=256&d=identicon&r=PG&f=y&so-version=2", "display_name": "Felix.B", "link": "https://stackoverflow.com/users/9152851/felix-b"}, "is_accepted": true, "score": 32, "last_activity_date": 1699663384, "last_edit_date": 1699663384, "creation_date": 1661433045, "answer_id": 73488117, "question_id": 73193006, "content_license": "CC BY-SA 4.0", "body": "<p>The values in the numpy array or list <code>predictions</code> can be add to a polars table using:</p>\n<pre class=\"lang-py prettyprint-override\"><code>predictions = [10, 20, 30, 40, 50]\ndf.with_columns(pl.Series(name=&quot;predictions&quot;, values=predictions)) \n</code></pre>\n"}, {"owner": {"account_id": 9013269, "reputation": 13413, "user_id": 6717054, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/72a7bcb06a087a25530bcbab56c2024f?s=256&d=identicon&r=PG", "display_name": "ritchie46", "link": "https://stackoverflow.com/users/6717054/ritchie46"}, "is_accepted": true, "score": 31, "last_activity_date": 1721181159, "last_edit_date": 1721181159, "creation_date": 1634303500, "answer_id": 69585269, "question_id": 69575496, "content_license": "CC BY-SA 4.0", "body": "<p>Polars has the <a href=\"https://docs.pola.rs/api/python/dev/reference/expressions/api/polars.corr.html\" rel=\"nofollow noreferrer\"><code>pl.corr()</code></a> function which supports <code>method=&quot;spearman&quot;</code></p>\n<p>If you want to use a custom function you could do it like this:</p>\n<h2>Custom function on multiple columns/expressions</h2>\n<pre class=\"lang-py prettyprint-override\"><code>import polars as pl\nfrom typing import List\nfrom scipy import stats\n\ndf = pl.DataFrame({\n    &quot;g&quot;: [1, 1, 1, 2, 2, 2, 5],\n    &quot;a&quot;: [2, 4, 5, 190, 1, 4, 1],\n    &quot;b&quot;: [1, 3, 2, 1, 43, 3, 1]\n})\n\ndef get_score(args: List[pl.Series]) -&gt; pl.Series:\n    return pl.Series([stats.spearmanr(args[0], args[1]).correlation], dtype=pl.Float64)\n\n(df.group_by(&quot;g&quot;, maintain_order=True)\n .agg(\n    pl.map_groups(\n        exprs=[&quot;a&quot;, &quot;b&quot;], \n        function=get_score).alias(&quot;corr&quot;)\n ))\n</code></pre>\n<h2>Polars provided function</h2>\n<pre class=\"lang-py prettyprint-override\"><code>(df.group_by(&quot;g&quot;, maintain_order=True)\n .agg(\n     pl.corr(&quot;a&quot;, &quot;b&quot;, method=&quot;spearman&quot;).alias(&quot;corr&quot;)\n ))\n</code></pre>\n<p>Both output:</p>\n<pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 g   \u2506 corr \u2502\n\u2502 --- \u2506 ---  \u2502\n\u2502 i64 \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 0.5  \u2502\n\u2502 2   \u2506 -1.0 \u2502\n\u2502 5   \u2506 NaN  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<h2>Custom function on a a single column/expression</h2>\n<p>We can also apply custom functions on single expressions, via <code>.map_elements</code></p>\n<p>Below is an example of how we can square a column with a custom function and with normal polars expressions. The expression syntax\nshould always be preferred, as its a lot faster.</p>\n<pre class=\"lang-py prettyprint-override\"><code>(df.group_by(&quot;g&quot;)\n .agg(\n     pl.col(&quot;a&quot;).map_elements(lambda group: group**2).alias(&quot;squared1&quot;),\n     (pl.col(&quot;a&quot;)**2).alias(&quot;squared2&quot;)\n ))\n</code></pre>\n"}, {"owner": {"account_id": 9013269, "reputation": 13413, "user_id": 6717054, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/72a7bcb06a087a25530bcbab56c2024f?s=256&d=identicon&r=PG", "display_name": "ritchie46", "link": "https://stackoverflow.com/users/6717054/ritchie46"}, "is_accepted": true, "score": 31, "last_activity_date": 1659935413, "last_edit_date": 1659935413, "creation_date": 1659434828, "answer_id": 73205690, "question_id": 73203318, "content_license": "CC BY-SA 4.0", "body": "<h2>Context</h2>\n<p>Pyspark uses arrow to convert to pandas. Polars is an abstraction over arrow memory. So we can hijack the API that spark uses internally to create the arrow data and use that to create the polars <code>DataFrame</code>.</p>\n<h2>TLDR</h2>\n<p>Given an spark context we can write:</p>\n<pre class=\"lang-py prettyprint-override\"><code>import pyarrow as pa\nimport polars as pl\n\nsql_context = SQLContext(spark)\n\ndata = [('James',[1, 2]),]\nspark_df = sql_context.createDataFrame(data=data, schema = [&quot;name&quot;,&quot;properties&quot;])\n\ndf = pl.from_arrow(pa.Table.from_batches(spark_df._collect_as_arrow()))\n\nprint(df)\n</code></pre>\n<pre><code>shape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 name  \u2506 properties \u2502\n\u2502 ---   \u2506 ---        \u2502\n\u2502 str   \u2506 list[i64]  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 James \u2506 [1, 2]     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<h2>Serialization steps</h2>\n<p>This will actually be faster than the <code>toPandas</code> provided by <code>spark</code> itself, because it saves an extra copy.</p>\n<p><code>toPandas()</code> will lead to this serialization/copy step:</p>\n<p><code>spark-memory -&gt; arrow-memory -&gt; pandas-memory</code></p>\n<p>With the query provided we have:</p>\n<p><code>spark-memory -&gt; arrow/polars-memory</code></p>\n"}, {"owner": {"account_id": 6180931, "reputation": 1936, "user_id": 4816462, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/fa3aaec297908ee9e50c8f730b55f3e0?s=256&d=identicon&r=PG&f=y&so-version=2", "display_name": "NFern", "link": "https://stackoverflow.com/users/4816462/nfern"}, "is_accepted": false, "score": 30, "last_activity_date": 1671323914, "last_edit_date": 1671323914, "creation_date": 1664451621, "answer_id": 73894918, "question_id": 71353113, "content_license": "CC BY-SA 4.0", "body": "<p>Using the <code>select</code> method is the recommended way to sort columns in polars.</p>\n<p>Example:</p>\n<p>Input:</p>\n<pre><code>df\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Col1 \u2506 Col2  \u2506Col3 \u2502\n\u2502 --- \u2506 ---   \u2506 --- \u2502\n\u2502 str \u2506 str   \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 x     \u2506 p   \u2502\n\u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u2524\n\u2502 b   \u2506 y     \u2506 q   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>Output:</p>\n<pre><code>df.select(['Col3', 'Col2', 'Col1'])\nor\ndf.select([pl.col('Col3'), pl.col('Col2'), pl.col('Col1)])\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502Col3 \u2506 Col2  \u2506Col1 \u2502\n\u2502 --- \u2506 ---   \u2506 --- \u2502\n\u2502 str \u2506 str   \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 p   \u2506 x     \u2506 a   \u2502\n\u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u2524\n\u2502 q   \u2506 y     \u2506 b   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>Note:\nWhile <code>df[['Col3', 'Col2', 'Col1']]</code> gives the same result (version 0.14), it is recommended (<a href=\"https://pola-rs.github.io/polars-book/user-guide/howcani/selecting_data/selecting_data_intro.html\" rel=\"noreferrer\">link</a>) that you use the select method instead.</p>\n<blockquote>\n<p>We strongly recommend selecting data with expressions for almost all\nuse cases. Square bracket indexing is perhaps useful when doing\nexploratory data analysis in a terminal or notebook when you just want\na quick look at a subset of data.</p>\n<p>For all other use cases we recommend using expressions because:</p>\n<ol>\n<li>expressions can be parallelized</li>\n<li>the expression approach can be used in lazy and eager mode while the indexing approach can only be used in eager mode</li>\n<li>in lazy mode the query optimizer can optimize expressions</li>\n</ol>\n</blockquote>\n"}, {"owner": {"account_id": 9013269, "reputation": 13413, "user_id": 6717054, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/72a7bcb06a087a25530bcbab56c2024f?s=256&d=identicon&r=PG", "display_name": "ritchie46", "link": "https://stackoverflow.com/users/6717054/ritchie46"}, "is_accepted": true, "score": 27, "last_activity_date": 1720515319, "last_edit_date": 1720515319, "creation_date": 1643903302, "answer_id": 70974264, "question_id": 70968749, "content_license": "CC BY-SA 4.0", "body": "<h2>Edit 2024-07-09</h2>\n<p>Polars has dedicated <a href=\"https://docs.pola.rs/api/python/dev/reference/expressions/api/polars.Expr.replace.html#polars.Expr.replace\" rel=\"nofollow noreferrer\"><code>replace</code></a> and <a href=\"https://docs.pola.rs/api/python/dev/reference/expressions/api/polars.Expr.replace_strict.html#polars.Expr.replace_strict\" rel=\"nofollow noreferrer\"><code>replace_strict</code></a> expressions.</p>\n<pre class=\"lang-py prettyprint-override\"><code>df = pl.DataFrame({\n    &quot;a&quot;: [1, 2, 3, 4, 5]\n})\n\nmapper = {\n    1: 0,\n    2: 0,\n    3: 10,\n    4: 10\n}\n\ndf.select(\n    pl.all().replace(mapper)\n)\n</code></pre>\n<pre><code>shape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2502\n\u2502 0   \u2502\n\u2502 10  \u2502\n\u2502 10  \u2502\n\u2502 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<h2>Before Edit</h2>\n<p>In polars you can build columnar <code>if else statetements</code> called <code>if -&gt; then -&gt; otherwise</code> expressions.</p>\n<p>So let's say we have this <code>DataFrame</code>.</p>\n<pre class=\"lang-py prettyprint-override\"><code>df = pl.DataFrame({\n    &quot;a&quot;: [1, 2, 3, 4, 5]\n})\n</code></pre>\n<p>And we'd like to replace these with the following values:</p>\n<pre class=\"lang-py prettyprint-override\"><code>from_ = [1, 2]\nto_ = [99, 12]\n</code></pre>\n<p>We could write:</p>\n<pre class=\"lang-py prettyprint-override\"><code>df.with_columns(\n    pl.when(pl.col(&quot;a&quot;) == from_[0])\n    .then(to_[0])\n    .when(pl.col(&quot;a&quot;) == from_[1])\n    .then(to_[1])\n    .otherwise(pl.col(&quot;a&quot;)).alias(&quot;a&quot;)\n)\n</code></pre>\n<pre><code>shape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 99  \u2502\n\u2502 12  \u2502\n\u2502 3   \u2502\n\u2502 4   \u2502\n\u2502 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<h1>Don't repeat yourself</h1>\n<p>Now, this becomes very tedious to write really fast, so we could write a function that generates these expressions for use, we are programmers aren't we!</p>\n<p>So to replace with the values you have suggested, you could do:</p>\n<pre class=\"lang-py prettyprint-override\"><code>from_ = [1,2,3,4,97,98,99]\nto_ = [0,0,1,1,2,2,2]\n\n\ndef replace(column, from_, to_):\n    # initiate the expression with `pl.when`\n    branch = pl.when(pl.col(column) == from_[0]).then(to_[0])\n\n    \n    # for every value add a `when.then`\n    for (from_value, to_value) in zip(from_, to_):\n        branch = branch.when(pl.col(column) == from_value).then(to_value)\n\n    # finish with an `otherwise`\n    return branch.otherwise(pl.col(column)).alias(column)\n    \n\n\ndf.with_columns(replace(&quot;a&quot;, from_, to_))\n</code></pre>\n<p>Which outputs:</p>\n<pre><code>shape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2502\n\u2502 0   \u2502\n\u2502 1   \u2502\n\u2502 1   \u2502\n\u2502 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n"}, {"owner": {"account_id": 252240, "reputation": 23702, "user_id": 530160, "user_type": "registered", "accept_rate": 69, "profile_image": "https://i.sstatic.net/xRnFS.jpg?s=256", "display_name": "Nick ODell", "link": "https://stackoverflow.com/users/530160/nick-odell"}, "is_accepted": true, "score": 27, "last_activity_date": 1726069998, "last_edit_date": 1726069998, "creation_date": 1648938016, "answer_id": 71721580, "question_id": 71721497, "content_license": "CC BY-SA 4.0", "body": "<p>Like so:</p>\n<pre class=\"lang-py prettyprint-override\"><code>literal = pl.lit(0.5)\nval = pl.select(literal).item()\n</code></pre>\n<p>Explanation: a Polars literal is an Expr object. An Expr object can be evaluated using <a href=\"https://docs.pola.rs/py-polars/html/reference/expressions/api/polars.select.html\" rel=\"nofollow noreferrer\"><code>pl.select()</code></a>. That returns a DataFrame. To get the scalar value from the DataFrame, you can use  <a href=\"https://docs.pola.rs/py-polars/html/reference/dataframe/api/polars.DataFrame.item.html\" rel=\"nofollow noreferrer\"><code>DataFrame.item()</code></a>.</p>\n<p>Note: <code>.item()</code> was added <a href=\"https://github.com/pola-rs/polars/releases/tag/py-0.15.9\" rel=\"nofollow noreferrer\">in release 0.15.9 of polars</a>. If you are using a version prior to this, you can use <code>pl.select(literal)[0, 0]</code> as an alternative.</p>\n"}, {"owner": {"account_id": 38212, "reputation": 13550, "user_id": 109525, "user_type": "registered", "accept_rate": 91, "profile_image": "https://i.sstatic.net/1Ffj0.jpg?s=256", "display_name": "0x26res", "link": "https://stackoverflow.com/users/109525/0x26res"}, "is_accepted": true, "score": 27, "last_activity_date": 1675344413, "creation_date": 1675344413, "answer_id": 75323864, "question_id": 75323747, "content_license": "CC BY-SA 4.0", "body": "<p>You can specify that you want the rows to be <a href=\"https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.rows.html#polars.DataFrame.rows\" rel=\"noreferrer\">named</a></p>\n<pre><code>for row in mydf.rows(named=True):\n    print(row)\n</code></pre>\n<p>It will give you a dict:</p>\n<pre><code>{'start_date': '2020-01-02', 'Name': 'John'}\n{'start_date': '2020-01-03', 'Name': 'Joe'}\n{'start_date': '2020-01-04', 'Name': 'James'}\n</code></pre>\n<p>You can then call <code>row['Name']</code></p>\n<p>Note that:</p>\n<ul>\n<li>previous versions returned namedtuple instead of dict.</li>\n<li>it's less memory intensive to use <a href=\"https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.iter_rows.html#polars.DataFrame.iter_rows\" rel=\"noreferrer\"><code>iter_rows</code></a></li>\n<li>overall it's not recommended to iterate through the data this way</li>\n</ul>\n<blockquote>\n<p>Row iteration is not optimal as the underlying data is stored in columnar form; where possible, prefer export via one of the dedicated export/output methods.</p>\n</blockquote>\n"}, {"owner": {"account_id": 15267393, "reputation": 1636, "user_id": 11015558, "user_type": "registered", "profile_image": "https://i.sstatic.net/lzHbT.png?s=256", "display_name": "Luca", "link": "https://stackoverflow.com/users/11015558/luca"}, "is_accepted": true, "score": 25, "last_activity_date": 1678699926, "creation_date": 1678699926, "answer_id": 75720073, "question_id": 75720011, "content_license": "CC BY-SA 4.0", "body": "<p>you can use <code>with_columns</code> and <code>pl.lit</code> to add a new column with Polars that is a constant and not based on existing columns.</p>\n<p>You can use it for both text and numbers.</p>\n<p>Here is an example:</p>\n<pre><code>df.with_columns(\n    new_column = pl.lit('some_text')\n)\n</code></pre>\n<p>The advantage of Polars is that all new columns added and all columns transformed within the same <code>with_columns</code> will be calculated in parallel.</p>\n"}, {"owner": {"user_type": "does_not_exist", "display_name": "user18559875"}, "is_accepted": true, "score": 23, "last_activity_date": 1720379633, "last_edit_date": 1720379633, "creation_date": 1658693374, "answer_id": 73101672, "question_id": 73101521, "content_license": "CC BY-SA 4.0", "body": "<p>You can use the <a href=\"https://docs.pola.rs/api/python/stable/reference/expressions/api/polars.Expr.over.html#polars.Expr.over\" rel=\"nofollow noreferrer\"><code>over</code></a> expression to accomplish this in Polars.  Using the example from the link...</p>\n<pre class=\"lang-py prettyprint-override\"><code>import polars as pl\n\ndf = pl.DataFrame({\n    &quot;a&quot;: [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;],\n    &quot;b&quot;: [1, 2, 3, 5, 3],\n    &quot;c&quot;: [5, 4, 3, 2, 1],\n})\n\ndf.with_columns(\n    pl.col(&quot;b&quot;).shift().over(&quot;a&quot;).alias(&quot;prev_value&quot;)\n)\n</code></pre>\n<pre><code>shape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2506 prev_value \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2506 ---        \u2502\n\u2502 str \u2506 i64 \u2506 i64 \u2506 i64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2506 5   \u2506 null       \u2502\n\u2502 a   \u2506 2   \u2506 4   \u2506 1          \u2502\n\u2502 b   \u2506 3   \u2506 3   \u2506 null       \u2502\n\u2502 b   \u2506 5   \u2506 2   \u2506 3          \u2502\n\u2502 b   \u2506 3   \u2506 1   \u2506 5          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>To perform this on more than one column, you can specify the columns in the <code>pl.col</code> expression, and then use a prefix/suffix to name the new columns.  For example:</p>\n<pre class=\"lang-py prettyprint-override\"><code>df.with_columns(\n    pl.col(&quot;b&quot;, &quot;c&quot;).shift().over(&quot;a&quot;).name.prefix(&quot;prev_&quot;)\n)\n</code></pre>\n<pre><code>shape: (5, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2506 prev_b \u2506 prev_c \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2506 ---    \u2506 ---    \u2502\n\u2502 str \u2506 i64 \u2506 i64 \u2506 i64    \u2506 i64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2506 5   \u2506 null   \u2506 null   \u2502\n\u2502 a   \u2506 2   \u2506 4   \u2506 1      \u2506 5      \u2502\n\u2502 b   \u2506 3   \u2506 3   \u2506 null   \u2506 null   \u2502\n\u2502 b   \u2506 5   \u2506 2   \u2506 3      \u2506 3      \u2502\n\u2502 b   \u2506 3   \u2506 1   \u2506 5      \u2506 2      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<h4>Using multiple values with <code>over</code></h4>\n<p>Let&quot;s use this data.</p>\n<pre class=\"lang-py prettyprint-override\"><code>df = pl.DataFrame(\n    {\n        &quot;id&quot;: [1] * 5 + [2] * 5,\n        &quot;date&quot;: [&quot;2020-01-01&quot;, &quot;2020-01-01&quot;, &quot;2020-02-01&quot;, &quot;2020-02-01&quot;, &quot;2020-02-01&quot;] * 2,\n        &quot;value1&quot;: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n        &quot;value2&quot;: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100],\n    }\n).with_columns(pl.col(&quot;date&quot;).str.to_date())\ndf\n</code></pre>\n<pre><code>shape: (10, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 id  \u2506 date       \u2506 value1 \u2506 value2 \u2502\n\u2502 --- \u2506 ---        \u2506 ---    \u2506 ---    \u2502\n\u2502 i64 \u2506 date       \u2506 i64    \u2506 i64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2020-01-01 \u2506 1      \u2506 10     \u2502\n\u2502 1   \u2506 2020-01-01 \u2506 2      \u2506 20     \u2502\n\u2502 1   \u2506 2020-02-01 \u2506 3      \u2506 30     \u2502\n\u2502 1   \u2506 2020-02-01 \u2506 4      \u2506 40     \u2502\n\u2502 1   \u2506 2020-02-01 \u2506 5      \u2506 50     \u2502\n\u2502 2   \u2506 2020-01-01 \u2506 6      \u2506 60     \u2502\n\u2502 2   \u2506 2020-01-01 \u2506 7      \u2506 70     \u2502\n\u2502 2   \u2506 2020-02-01 \u2506 8      \u2506 80     \u2502\n\u2502 2   \u2506 2020-02-01 \u2506 9      \u2506 90     \u2502\n\u2502 2   \u2506 2020-02-01 \u2506 10     \u2506 100    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>We can place a list of our grouping variables in the <code>over</code> expression (as well as a list in our <code>pl.col</code> expression).  Polars will run them all in parallel.</p>\n<pre class=\"lang-py prettyprint-override\"><code>df.with_columns(\n    pl.col(&quot;value1&quot;, &quot;value2&quot;).shift().over(&quot;id&quot;, &quot;date&quot;).name.prefix(&quot;prev_&quot;),\n    pl.col(&quot;value1&quot;, &quot;value2&quot;).diff().over(&quot;id&quot;, &quot;date&quot;).name.suffix(&quot;_diff&quot;)\n)\n</code></pre>\n<pre><code>shape: (10, 8)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 id  \u2506 date       \u2506 value1 \u2506 value2 \u2506 prev_value1 \u2506 prev_value2 \u2506 value1_diff \u2506 value2_diff \u2502\n\u2502 --- \u2506 ---        \u2506 ---    \u2506 ---    \u2506 ---         \u2506 ---         \u2506 ---         \u2506 ---         \u2502\n\u2502 i64 \u2506 date       \u2506 i64    \u2506 i64    \u2506 i64         \u2506 i64         \u2506 i64         \u2506 i64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2020-01-01 \u2506 1      \u2506 10     \u2506 null        \u2506 null        \u2506 null        \u2506 null        \u2502\n\u2502 1   \u2506 2020-01-01 \u2506 2      \u2506 20     \u2506 1           \u2506 10          \u2506 1           \u2506 10          \u2502\n\u2502 1   \u2506 2020-02-01 \u2506 3      \u2506 30     \u2506 null        \u2506 null        \u2506 null        \u2506 null        \u2502\n\u2502 1   \u2506 2020-02-01 \u2506 4      \u2506 40     \u2506 3           \u2506 30          \u2506 1           \u2506 10          \u2502\n\u2502 1   \u2506 2020-02-01 \u2506 5      \u2506 50     \u2506 4           \u2506 40          \u2506 1           \u2506 10          \u2502\n\u2502 2   \u2506 2020-01-01 \u2506 6      \u2506 60     \u2506 null        \u2506 null        \u2506 null        \u2506 null        \u2502\n\u2502 2   \u2506 2020-01-01 \u2506 7      \u2506 70     \u2506 6           \u2506 60          \u2506 1           \u2506 10          \u2502\n\u2502 2   \u2506 2020-02-01 \u2506 8      \u2506 80     \u2506 null        \u2506 null        \u2506 null        \u2506 null        \u2502\n\u2502 2   \u2506 2020-02-01 \u2506 9      \u2506 90     \u2506 8           \u2506 80          \u2506 1           \u2506 10          \u2502\n\u2502 2   \u2506 2020-02-01 \u2506 10     \u2506 100    \u2506 9           \u2506 90          \u2506 1           \u2506 10          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n"}, {"owner": {"user_type": "does_not_exist", "display_name": "user18559875"}, "is_accepted": false, "score": 21, "last_activity_date": 1721468809, "last_edit_date": 1721468809, "creation_date": 1649378033, "answer_id": 71790405, "question_id": 71790235, "content_license": "CC BY-SA 4.0", "body": "<p>The easiest way to accomplish this is with the <a href=\"https://docs.pola.rs/api/python/stable/reference/expressions/api/polars.Expr.cast.html\" rel=\"nofollow noreferrer\"><code>cast</code></a> expression.</p>\n<h4>String to Int/Float</h4>\n<p>To cast from a string to an integer (or float):</p>\n<pre class=\"lang-py prettyprint-override\"><code>import polars as pl\n\ndf = pl.DataFrame({&quot;bar&quot;: [&quot;100&quot;, &quot;250&quot;, &quot;125&quot;, &quot;&quot;]})\ndf.with_columns(pl.col('bar').cast(pl.Int64, strict=False).alias('bar_int'))\n</code></pre>\n<pre><code>shape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 bar \u2506 bar_int \u2502\n\u2502 --- \u2506 ---     \u2502\n\u2502 str \u2506 i64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 100 \u2506 100     \u2502\n\u2502 250 \u2506 250     \u2502\n\u2502 125 \u2506 125     \u2502\n\u2502     \u2506 null    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>A handy list of available datatypes is <a href=\"https://docs.pola.rs/user-guide/concepts/data-types/overview/\" rel=\"nofollow noreferrer\">here</a>.  These are all aliased under <code>polars</code>, so you can refer to them easily (e.g., <code>pl.UInt64</code>).</p>\n<p>For the data you describe, I recommend using <code>strict=False</code> to avoid having one mangled number among millions of records result in an exception that halts everything.</p>\n<h4>Int/Float to String</h4>\n<p>The same process can be used to convert numbers to strings - in this case, the utf8 datatype.</p>\n<p>Let me modify your dataset slightly:</p>\n<pre class=\"lang-py prettyprint-override\"><code>df = pl.DataFrame({&quot;bar&quot;: [100.5, 250.25, 1250000, None]})\ndf.with_columns(pl.col(&quot;bar&quot;).cast(pl.String, strict=False).alias(&quot;bar_string&quot;))\n</code></pre>\n<pre><code>shape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 bar    \u2506 bar_string \u2502\n\u2502 ---    \u2506 ---        \u2502\n\u2502 f64    \u2506 str        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 100.5  \u2506 100.5      \u2502\n\u2502 250.25 \u2506 250.25     \u2502\n\u2502 1.25e6 \u2506 1250000.0  \u2502\n\u2502 null   \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>If you need more control over the formatting, you can use the <code>map_elements</code> method and Python's new f-string formatting.</p>\n<pre class=\"lang-py prettyprint-override\"><code>df.with_columns(\n    pl.col(&quot;bar&quot;).map_elements(lambda x: f&quot;This is ${x:,.2f}!&quot;).alias(&quot;bar_fstring&quot;)\n)\n</code></pre>\n<pre><code>shape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 bar    \u2506 bar_fstring            \u2502\n\u2502 ---    \u2506 ---                    \u2502\n\u2502 f64    \u2506 str                    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 100.5  \u2506 This is $100.50!       \u2502\n\u2502 250.25 \u2506 This is $250.25!       \u2502\n\u2502 1.25e6 \u2506 This is $1,250,000.00! \u2502\n\u2502 null   \u2506 null                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>I found <a href=\"https://datagy.io/python-f-strings/\" rel=\"nofollow noreferrer\">this web page</a> to be a handy reference for those unfamiliar with f-string formatting.</p>\n"}, {"owner": {"user_type": "does_not_exist", "display_name": "user18559875"}, "is_accepted": true, "score": 21, "last_activity_date": 1721472587, "last_edit_date": 1721472587, "creation_date": 1652587297, "answer_id": 72245435, "question_id": 72245243, "content_license": "CC BY-SA 4.0", "body": "<p>Let's start with this DataFrame:</p>\n<pre class=\"lang-py prettyprint-override\"><code>import polars as pl\n\ndf = pl.DataFrame(\n    {\n        &quot;col1&quot;: [1, 2, 3, 4, 5],\n    }\n)\n</code></pre>\n<pre><code>shape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2502\n\u2502 ---  \u2502\n\u2502 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2502\n\u2502 2    \u2502\n\u2502 3    \u2502\n\u2502 4    \u2502\n\u2502 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<h4>To add a scalar (single value)</h4>\n<p>Use <a href=\"https://docs.pola.rs/api/python/stable/reference/expressions/api/polars.lit.html\" rel=\"nofollow noreferrer\"><code>polars.lit</code></a>.</p>\n<pre class=\"lang-py prettyprint-override\"><code>my_scalar = -1\ndf.with_columns(pl.lit(my_scalar).alias(&quot;col_scalar&quot;))\n</code></pre>\n<pre><code>shape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col_scalar \u2502\n\u2502 ---  \u2506 ---        \u2502\n\u2502 i64  \u2506 i32        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 -1         \u2502\n\u2502 2    \u2506 -1         \u2502\n\u2502 3    \u2506 -1         \u2502\n\u2502 4    \u2506 -1         \u2502\n\u2502 5    \u2506 -1         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>You can also choose the datatype of the new column using the <code>dtype</code> keyword.</p>\n<pre class=\"lang-py prettyprint-override\"><code>df.with_columns(pl.lit(my_scalar, dtype=pl.Float64).alias(&quot;col_scalar_float&quot;))\n</code></pre>\n<pre><code>shape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col_scalar_float \u2502\n\u2502 ---  \u2506 ---              \u2502\n\u2502 i64  \u2506 f64              \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 -1.0             \u2502\n\u2502 2    \u2506 -1.0             \u2502\n\u2502 3    \u2506 -1.0             \u2502\n\u2502 4    \u2506 -1.0             \u2502\n\u2502 5    \u2506 -1.0             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<h4>To add a list</h4>\n<p>To add a list of values (perhaps from some external computation), use the <a href=\"https://docs.pola.rs/api/python/stable/reference/series/index.html#series\" rel=\"nofollow noreferrer\">polars.Series</a> constructor and provide a name to the Series constructor.</p>\n<pre class=\"lang-py prettyprint-override\"><code>my_list = [10, 20, 30, 40, 50]\ndf.with_columns(pl.Series(name=&quot;col_list&quot;, values=my_list))\n</code></pre>\n<pre><code>shape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col_list \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 10       \u2502\n\u2502 2    \u2506 20       \u2502\n\u2502 3    \u2506 30       \u2502\n\u2502 4    \u2506 40       \u2502\n\u2502 5    \u2506 50       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>You can use the <code>dtype</code> keyword to control the datatype of the new series, if needed.</p>\n<pre class=\"lang-py prettyprint-override\"><code>df.with_columns(pl.Series(name=&quot;col_list&quot;, values=my_list, dtype=pl.Float64))\n</code></pre>\n<pre><code>shape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col_list \u2502\n\u2502 ---  \u2506 ---      \u2502\n\u2502 i64  \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 10.0     \u2502\n\u2502 2    \u2506 20.0     \u2502\n\u2502 3    \u2506 30.0     \u2502\n\u2502 4    \u2506 40.0     \u2502\n\u2502 5    \u2506 50.0     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<h4>To add a Series</h4>\n<p>If you already have a Series, you can just provide a reference to it.</p>\n<pre class=\"lang-py prettyprint-override\"><code>my_series = pl.Series(name=&quot;my_series_name&quot;, values=[10, 20, 30, 40, 50])\ndf.with_columns(my_series)\n</code></pre>\n<pre><code>shape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 my_series_name \u2502\n\u2502 ---  \u2506 ---            \u2502\n\u2502 i64  \u2506 i64            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 10             \u2502\n\u2502 2    \u2506 20             \u2502\n\u2502 3    \u2506 30             \u2502\n\u2502 4    \u2506 40             \u2502\n\u2502 5    \u2506 50             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>If your Series does not already have a name, you can provide one using the <code>alias</code> Expression.</p>\n<pre class=\"lang-py prettyprint-override\"><code>my_series_no_name = pl.Series(values=[10, 20, 30, 40, 50])\ndf.with_columns(my_series_no_name.alias('col_no_name'))\n</code></pre>\n<pre><code>shape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 col1 \u2506 col_no_name \u2502\n\u2502 ---  \u2506 ---         \u2502\n\u2502 i64  \u2506 i64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 10          \u2502\n\u2502 2    \u2506 20          \u2502\n\u2502 3    \u2506 30          \u2502\n\u2502 4    \u2506 40          \u2502\n\u2502 5    \u2506 50          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n"}, {"owner": {"account_id": 9013269, "reputation": 13413, "user_id": 6717054, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/72a7bcb06a087a25530bcbab56c2024f?s=256&d=identicon&r=PG", "display_name": "ritchie46", "link": "https://stackoverflow.com/users/6717054/ritchie46"}, "is_accepted": true, "score": 20, "last_activity_date": 1721565427, "last_edit_date": 1721565427, "creation_date": 1623403804, "answer_id": 67934527, "question_id": 67834912, "content_license": "CC BY-SA 4.0", "body": "<p>You can use the expression syntax to select all columns with <code>pl.all()</code> and then <a href=\"https://docs.pola.rs/api/python/stable/reference/expressions/api/polars.map_batches.html#polars-map-batches\" rel=\"nofollow noreferrer\"><code>map_batches</code></a> the numpy <code>np.log2(..)</code> function over the columns.</p>\n<pre class=\"lang-py prettyprint-override\"><code>df.select(\n    pl.all().map_batches(np.log2)\n)\n</code></pre>\n<p>Note that we choose <code>map_batches</code> here as <code>map_elements</code> would call the function upon each value.</p>\n<pre class=\"lang-py prettyprint-override\"><code>map_elements = pl.Series(np.log2(value) for value in pl.Series([1, 2, 3]))\n</code></pre>\n<p>But <code>np.log2</code> can be called once with multiple values, which would be faster.</p>\n<pre class=\"lang-py prettyprint-override\"><code>map_batches = np.log2(pl.Series([1, 2, 3]))\n</code></pre>\n<p>See the <a href=\"https://docs.pola.rs/user-guide/expressions/user-defined-functions/#processing-a-whole-series-with-map_batches\" rel=\"nofollow noreferrer\">User guide</a> for more.</p>\n<ul>\n<li><code>map_elements</code>: Call a function separately on each value in the Series.</li>\n<li><code>map_batches</code>: Always passes the full Series to the function.</li>\n</ul>\n<h3>Numpy</h3>\n<p>Polars expressions <a href=\"https://docs.pola.rs/user-guide/expressions/numpy/\" rel=\"nofollow noreferrer\">also support</a> numpy <a href=\"https://numpy.org/doc/stable/reference/ufuncs.html#available-ufuncs\" rel=\"nofollow noreferrer\">universal functions.</a></p>\n<p>That means you can pass a polars expression to a numpy <code>ufunc</code>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>df.select(\n    np.log2(pl.all())\n)\n</code></pre>\n"}, {"owner": {"account_id": 9013269, "reputation": 13413, "user_id": 6717054, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/72a7bcb06a087a25530bcbab56c2024f?s=256&d=identicon&r=PG", "display_name": "ritchie46", "link": "https://stackoverflow.com/users/6717054/ritchie46"}, "is_accepted": true, "score": 20, "last_activity_date": 1644823329, "creation_date": 1644823329, "answer_id": 71108347, "question_id": 71106690, "content_license": "CC BY-SA 4.0", "body": "<p>Reading all data in a csv to any other type than <code>pl.Utf8</code> likely fails with a lot of <code>null</code> values. We can use expressions to declare how we want to deal with those null values.</p>\n<p>If you read a csv with <code>infer_schema_length=0</code>, polars does not know the schema and will read all columns as <code>pl.Utf8</code> as that is a super type of all polars types.</p>\n<p>When read as <code>Utf8</code> we can use expressions to cast all columns.</p>\n<pre class=\"lang-py prettyprint-override\"><code>(pl.read_csv(&quot;test.csv&quot;, infer_schema_length=0)\n   .with_columns(pl.all().cast(pl.Int32, strict=False))\n</code></pre>\n"}, {"owner": {"account_id": 9013269, "reputation": 13413, "user_id": 6717054, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/72a7bcb06a087a25530bcbab56c2024f?s=256&d=identicon&r=PG", "display_name": "ritchie46", "link": "https://stackoverflow.com/users/6717054/ritchie46"}, "is_accepted": false, "score": 20, "last_activity_date": 1721175284, "last_edit_date": 1721175284, "creation_date": 1648652209, "answer_id": 71679606, "question_id": 71658991, "content_license": "CC BY-SA 4.0", "body": "<p>The first step would be to check if your task can be solved natively using <a href=\"https://docs.pola.rs/user-guide/concepts/expressions/\" rel=\"nofollow noreferrer\">Polars Expressions</a>.</p>\n<p>If a custom function is neccessary, <a href=\"https://docs.pola.rs/api/python/dev/reference/expressions/api/polars.Expr.map_elements.html#polars-expr-map-elements\" rel=\"nofollow noreferrer\"><code>.map_elements()</code></a> can be used to apply one on a row by row basis.</p>\n<p>To pass in values from multiple columns, you can utilize the <a href=\"https://docs.pola.rs/user-guide/expressions/structs/#structs-as-dicts\" rel=\"nofollow noreferrer\">Struct</a> data type.</p>\n<p>e.g. with <a href=\"https://docs.pola.rs/api/python/dev/reference/expressions/api/polars.struct.html\" rel=\"nofollow noreferrer\"><code>pl.struct()</code></a></p>\n<pre class=\"lang-py prettyprint-override\"><code>&gt;&gt;&gt; df.select(pl.struct(pl.all())) # all columns\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo       \u2502\n\u2502 ---       \u2502\n\u2502 struct[3] \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 {1,4,7}   \u2502\n\u2502 {2,5,8}   \u2502\n\u2502 {3,6,9}   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>Using <code>pl.struct(...).map_elements</code> will pass the values to the custom function as a <code>dict</code> argument.</p>\n<pre class=\"lang-py prettyprint-override\"><code>def my_complicated_function(row: dict) -&gt; int:\n    &quot;&quot;&quot;\n    A function that cannot utilize polars expressions.\n    This should be avoided.\n    &quot;&quot;&quot;\n\n    # a dict with column names as keys\n    print(f&quot;[DEBUG]: {row=}&quot;)\n    \n    # do some work\n    return row[&quot;foo&quot;] + row[&quot;bar&quot;] + row[&quot;baz&quot;]\n\n\ndf = pl.DataFrame({\n    &quot;foo&quot;: [1, 2, 3], \n    &quot;bar&quot;: [4, 5, 6], \n    &quot;baz&quot;: [7, 8, 9]\n})\n\ndf = df.with_columns(\n    pl.struct(pl.all())\n      .map_elements(my_complicated_function, return_dtype=pl.Int64)\n      .alias(&quot;foo + bar + baz&quot;)\n)\n</code></pre>\n<pre class=\"lang-py prettyprint-override\"><code># [DEBUG]: row={'foo': 1, 'bar': 4, 'baz': 7}\n# [DEBUG]: row={'foo': 2, 'bar': 5, 'baz': 8}\n# [DEBUG]: row={'foo': 3, 'bar': 6, 'baz': 9}\n</code></pre>\n<pre class=\"lang-py prettyprint-override\"><code>shape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 baz \u2506 foo + bar + baz \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2506 ---             \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2506 i64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4   \u2506 7   \u2506 12              \u2502\n\u2502 2   \u2506 5   \u2506 8   \u2506 15              \u2502\n\u2502 3   \u2506 6   \u2506 9   \u2506 18              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n"}, {"owner": {"account_id": 9013269, "reputation": 13413, "user_id": 6717054, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/72a7bcb06a087a25530bcbab56c2024f?s=256&d=identicon&r=PG", "display_name": "ritchie46", "link": "https://stackoverflow.com/users/6717054/ritchie46"}, "is_accepted": true, "score": 20, "last_activity_date": 1685715810, "last_edit_date": 1685715810, "creation_date": 1655369660, "answer_id": 72643075, "question_id": 72642575, "content_license": "CC BY-SA 4.0", "body": "<p>Polars cares about schema correctness by default in operations and prefers throwing an error above silently succeeding as it might indicate a bug in your program.</p>\n<p>If you want <code>polars</code> to add the columns, add the kwarg <code>how=&quot;diagonal&quot;</code> to <code>pl.concat</code>.</p>\n<pre class=\"lang-py prettyprint-override\"><code>df_a = pl.DataFrame({\n    &quot;a&quot;: [1, 2, 3],\n    &quot;b&quot;: [True, None, False],\n})\n\n\ndf_b = pl.DataFrame({\n    &quot;a&quot;: [4, 5],\n    &quot;c&quot;: [&quot;bar&quot;, &quot;ham&quot;]\n})\n\n\npl.concat([df_a, df_b], how=&quot;diagonal&quot;)\n</code></pre>\n<pre><code>shape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b     \u2506 c    \u2502\n\u2502 --- \u2506 ---   \u2506 ---  \u2502\n\u2502 i64 \u2506 bool  \u2506 str  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 true  \u2506 null \u2502\n\u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n\u2502 2   \u2506 null  \u2506 null \u2502\n\u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n\u2502 3   \u2506 false \u2506 null \u2502\n\u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n\u2502 4   \u2506 null  \u2506 bar  \u2502\n\u251c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u254c\u253c\u254c\u254c\u254c\u254c\u254c\u254c\u2524\n\u2502 5   \u2506 null  \u2506 ham  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n</code></pre>\n"}, {"owner": {"account_id": 26897236, "reputation": 389, "user_id": 20474952, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/b348bc3e89590d8c1b0a41445d536458?s=256&d=identicon&r=PG&f=y&so-version=2", "display_name": "Regular Tech Guy", "link": "https://stackoverflow.com/users/20474952/regular-tech-guy"}, "is_accepted": false, "score": 20, "last_activity_date": 1668147536, "last_edit_date": 1668147536, "creation_date": 1668147307, "answer_id": 74398677, "question_id": 71788877, "content_license": "CC BY-SA 4.0", "body": "<p>Using the <code>polars.DataFrame.estimated_size()</code> method we can get the size of the dataframe similar to <code>pandas.info()</code>.</p>\n<p>Follow the <a href=\"https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.estimated_size.html\" rel=\"noreferrer\">link</a>.</p>\n"}, {"owner": {"user_type": "does_not_exist", "display_name": "user18559875"}, "is_accepted": true, "score": 19, "last_activity_date": 1720380492, "last_edit_date": 1720380492, "creation_date": 1652894010, "answer_id": 72293384, "question_id": 72292048, "content_license": "CC BY-SA 4.0", "body": "<h4>Series</h4>\n<p>For a single Series, you can use the <a href=\"https://docs.pola.rs/api/python/stable/reference/series/api/polars.Series.set.html\" rel=\"nofollow noreferrer\"><code>set</code></a> method.</p>\n<pre class=\"lang-py prettyprint-override\"><code>s = pl.Series([&quot;cow&quot;, &quot;cat&quot;, &quot;&quot;, &quot;lobster&quot;, &quot;&quot;])\ns.set(s.str.len_chars() == 0, None)\n</code></pre>\n<pre><code>shape: (5,)\nSeries: '' [str]\n[\n        &quot;cow&quot;\n        &quot;cat&quot;\n        null\n        &quot;lobster&quot;\n        null\n]\n</code></pre>\n<h4>DataFrame</h4>\n<p>For DataFrames, I would suggest using <a href=\"https://docs.pola.rs/api/python/dev/reference/expressions/api/polars.when.html#polars.when\" rel=\"nofollow noreferrer\"><code>when/then/otherwise</code></a>.  For example, with this data:</p>\n<pre class=\"lang-py prettyprint-override\"><code>df = pl.DataFrame({\n    &quot;str1&quot;: [&quot;cow&quot;, &quot;dog&quot;, &quot;&quot;, &quot;lobster&quot;, &quot;&quot;],\n    &quot;str2&quot;: [&quot;&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;&quot;, &quot;kiwi&quot;],\n    &quot;str3&quot;: [&quot;house&quot;, &quot;&quot;, &quot;apartment&quot;, &quot;condo&quot;, &quot;&quot;],\n})\n</code></pre>\n<pre><code>shape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 str1    \u2506 str2   \u2506 str3      \u2502\n\u2502 ---     \u2506 ---    \u2506 ---       \u2502\n\u2502 str     \u2506 str    \u2506 str       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 cow     \u2506        \u2506 house     \u2502\n\u2502 dog     \u2506 apple  \u2506           \u2502\n\u2502         \u2506 orange \u2506 apartment \u2502\n\u2502 lobster \u2506        \u2506 condo     \u2502\n\u2502         \u2506 kiwi   \u2506           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>We can run a replacement on all string columns as follows:</p>\n<pre class=\"lang-py prettyprint-override\"><code>df.with_columns(\n    pl.when(pl.col(pl.String).str.len_chars() == 0)\n    .then(None)\n    .otherwise(pl.col(pl.String))\n    .name.keep()\n)\n</code></pre>\n<pre><code>shape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 str1    \u2506 str2   \u2506 str3      \u2502\n\u2502 ---     \u2506 ---    \u2506 ---       \u2502\n\u2502 str     \u2506 str    \u2506 str       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 cow     \u2506 null   \u2506 house     \u2502\n\u2502 dog     \u2506 apple  \u2506 null      \u2502\n\u2502 null    \u2506 orange \u2506 apartment \u2502\n\u2502 lobster \u2506 null   \u2506 condo     \u2502\n\u2502 null    \u2506 kiwi   \u2506 null      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<p>The above should be fairly performant.</p>\n<p>If you only want to replace empty strings with null on certain columns, you can provide a list:</p>\n<pre class=\"lang-py prettyprint-override\"><code>only_these = [&quot;str1&quot;, &quot;str2&quot;]\ndf.with_columns(\n    pl.when(pl.col(only_these).str.len_chars() == 0)\n    .then(None)\n    .otherwise(pl.col(only_these))\n    .name.keep()\n)\n</code></pre>\n<pre><code>shape: (5, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 str1    \u2506 str2   \u2506 str3      \u2502\n\u2502 ---     \u2506 ---    \u2506 ---       \u2502\n\u2502 str     \u2506 str    \u2506 str       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 cow     \u2506 null   \u2506 house     \u2502\n\u2502 dog     \u2506 apple  \u2506           \u2502\n\u2502 null    \u2506 orange \u2506 apartment \u2502\n\u2502 lobster \u2506 null   \u2506 condo     \u2502\n\u2502 null    \u2506 kiwi   \u2506           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n"}, {"owner": {"account_id": 2036464, "reputation": 17282, "user_id": 1818713, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/62d34c70ac72915919cb256db6c05b24?s=256&d=identicon&r=PG", "display_name": "Dean MacGregor", "link": "https://stackoverflow.com/users/1818713/dean-macgregor"}, "is_accepted": true, "score": 19, "last_activity_date": 1706280441, "last_edit_date": 1706280441, "creation_date": 1668463972, "answer_id": 74438454, "question_id": 74433918, "content_license": "CC BY-SA 4.0", "body": "<p>In polars, you don't add columns by assigning just the value of the new column.  You always have to assign the whole df (in other words there's never <code>['col_3']</code> on the left side of the <code>=</code>)</p>\n<p>To that end if you want your original df with a new column then you use the <code>with_columns</code> method.</p>\n<p>you would do</p>\n<pre><code>df = df.with_columns(pl.struct(['col_1','col_2']) \\\n       .map_elements(lambda x: func(x['col_1'], x['col_2'])).alias('col_3'))\n</code></pre>\n<p>A struct is a dataframe inside a column of a dataframe. This is helpful because <code>map_elements</code> (and indeed all expressions) can only be invoked from a single column. The <code>map_elements</code> turns the struct, in each row, into dict and that becomes the input to your function. <code>map_elements</code> is for functions which take a single input and output a single value. (If you're using a vectorized function that expects something like a list and returns another list then you should use <code>map_batches</code>). Finally, you do <code>alias</code> on that to give it the name you want it to have.</p>\n"}, {"owner": {"account_id": 2036464, "reputation": 17282, "user_id": 1818713, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/62d34c70ac72915919cb256db6c05b24?s=256&d=identicon&r=PG", "display_name": "Dean MacGregor", "link": "https://stackoverflow.com/users/1818713/dean-macgregor"}, "is_accepted": true, "score": 19, "last_activity_date": 1705678488, "last_edit_date": 1705678488, "creation_date": 1676999364, "answer_id": 75523731, "question_id": 75523498, "content_license": "CC BY-SA 4.0", "body": "<h2>For polars 0.20.5+</h2>\n<p>To get the row count using polars.</p>\n<p>First load it into a lazyframe...</p>\n<pre><code>lzdf=pl.scan_csv(&quot;mybigfile.csv&quot;)\n</code></pre>\n<p>Then count the rows and return the result</p>\n<pre><code>lzdf.select(pl.len()).collect()\n</code></pre>\n<p>If you just want a python scalar rather than a table as a result then just subset it</p>\n<pre><code>lzdf.select(pl.len()).collect().item()\n</code></pre>\n<h2>For older versions</h2>\n<p>To get the row count using polars.</p>\n<p>First load it into a lazyframe...</p>\n<pre><code>lzdf=pl.scan_csv(&quot;mybigfile.csv&quot;)\n</code></pre>\n<p>Then count the rows and return the result</p>\n<pre><code>lzdf.select(pl.count()).collect()\n</code></pre>\n<p>If you just want a python scalar rather than a table as a result then just subset it</p>\n<pre><code>lzdf.select(pl.count()).collect().item()\n</code></pre>\n"}, {"owner": {"account_id": 2036464, "reputation": 17282, "user_id": 1818713, "user_type": "registered", "accept_rate": 89, "profile_image": "https://www.gravatar.com/avatar/62d34c70ac72915919cb256db6c05b24?s=256&d=identicon&r=PG", "display_name": "Dean MacGregor", "link": "https://stackoverflow.com/users/1818713/dean-macgregor"}, "is_accepted": true, "score": 19, "last_activity_date": 1702988134, "last_edit_date": 1702988134, "creation_date": 1681212276, "answer_id": 75985318, "question_id": 75984983, "content_license": "CC BY-SA 4.0", "body": "<p>You were really close with <code>with_columns(pl.when(pl.col(&quot;one&quot;) == &quot;a&quot;).then(&quot;hello&quot;))</code> but you needed to tell it which column that should be.</p>\n<p>When you don't tell it which column you're referring to then it has to guess and in this case it guessed the column you referred to.</p>\n<p>Instead you do</p>\n<pre><code>(df \n    .with_columns(\n        two=pl.when(pl.col('one')=='a')\n                .then(pl.lit('hello'))\n                .otherwise(pl.col('two')))\n)\n</code></pre>\n<p>This uses the **kwargs input of <code>with_columns</code> to allow the column named to be on the left of an equal sign as though it were a parameter to a function. You can also use alias syntax like this...</p>\n<pre><code>(df \n    .with_columns(\n        (pl.when(pl.col('one')=='a')\n                .then(pl.lit('hello'))\n                .otherwise(pl.col('two')))\n            .alias('two')\n                )\n)\n</code></pre>\n<p>Note that I wrapped the entire when/then/otherwise in parenthesis. The order of operations around when/then/otherwise and alias is weird so I find it's best to always completely wrap them in parenthesis to avoid unexpected results. Worst case scenario is you have redundant parenthesis which doesn't hurt anything.</p>\n"}, {"owner": {"account_id": 9013269, "reputation": 13413, "user_id": 6717054, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/72a7bcb06a087a25530bcbab56c2024f?s=256&d=identicon&r=PG", "display_name": "ritchie46", "link": "https://stackoverflow.com/users/6717054/ritchie46"}, "is_accepted": true, "score": 17, "last_activity_date": 1721575224, "last_edit_date": 1721575224, "creation_date": 1659468236, "answer_id": 73212748, "question_id": 73212628, "content_license": "CC BY-SA 4.0", "body": "<p>You can use <a href=\"https://docs.pola.rs/api/python/stable/reference/expressions/api/polars.Expr.dt.date.html#polars.Expr.dt.date\" rel=\"nofollow noreferrer\"><code>.dt.date()</code></a></p>\n<pre class=\"lang-py prettyprint-override\"><code>import datetime\nimport polars as pl\n\ndf = pl.DataFrame({\n    &quot;time&quot;: [datetime.datetime.now()]\n})\n\ndf.with_columns(\n    pl.col(&quot;time&quot;).dt.date().alias(&quot;date&quot;)\n)\n</code></pre>\n<pre><code>shape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 time                       \u2506 date       \u2502\n\u2502 ---                        \u2506 ---        \u2502\n\u2502 datetime[\u03bcs]               \u2506 date       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-07-21 16:17:41.489579 \u2506 2024-07-21 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n"}, {"owner": {"account_id": 160072, "reputation": 1199, "user_id": 379859, "user_type": "registered", "accept_rate": 80, "profile_image": "https://www.gravatar.com/avatar/bb35ab6f1ddc39bb13e7c00d2063c17c?s=256&d=identicon&r=PG", "display_name": "JohnRos", "link": "https://stackoverflow.com/users/379859/johnros"}, "is_accepted": false, "score": 16, "last_activity_date": 1669624089, "creation_date": 1669624089, "answer_id": 74597856, "question_id": 74301064, "content_license": "CC BY-SA 4.0", "body": "<p><code>pl.Config.set_tbl_rows(100)</code></p>\n<p>And more generally, I would try looking at <code>dir(pl.Config)</code></p>\n"}, {"owner": {"account_id": 20007061, "reputation": 703, "user_id": 14664861, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/f637b1981fc8edba9c8f7764a9243e8e?s=256&d=identicon&r=PG&f=y&so-version=2", "display_name": "chubercik", "link": "https://stackoverflow.com/users/14664861/chubercik"}, "is_accepted": true, "score": 16, "last_activity_date": 1677036808, "creation_date": 1677036808, "answer_id": 75528006, "question_id": 75525312, "content_license": "CC BY-SA 4.0", "body": "<p>How about the <a href=\"https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.rows.html\" rel=\"noreferrer\"><code>rows()</code></a> method?</p>\n<pre class=\"lang-py prettyprint-override\"><code>df = pl.DataFrame(\n    {\n        &quot;a&quot;: [1, 3, 5],\n        &quot;b&quot;: [2, 4, 6],\n    }\n)\n</code></pre>\n<pre class=\"lang-py prettyprint-override\"><code>df.rows()\n</code></pre>\n<p><code>[(1, 2), (3, 4), (5, 6)]</code></p>\n<pre class=\"lang-py prettyprint-override\"><code>df.rows(named=True)\n</code></pre>\n<p><code>[{'a': 1, 'b': 2}, {'a': 3, 'b': 4}, {'a': 5, 'b': 6}]</code></p>\n<p>Alternatively, you could get all the DataFrame's columns using the <a href=\"https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/api/polars.DataFrame.get_columns.html\" rel=\"noreferrer\"><code>get_columns()</code></a> method, which would give you a list of Series, which you can then convert into a list of lists using the <a href=\"https://pola-rs.github.io/polars/py-polars/html/reference/series/api/polars.Series.to_list.html\" rel=\"noreferrer\"><code>to_list()</code></a> method on each Series in the list.</p>\n<p>If that's not what you're looking for be sure to hit me up with a reply, maybe then I'll be able to be of help to you.</p>\n"}, {"owner": {"account_id": 9013269, "reputation": 13413, "user_id": 6717054, "user_type": "registered", "accept_rate": 86, "profile_image": "https://www.gravatar.com/avatar/72a7bcb06a087a25530bcbab56c2024f?s=256&d=identicon&r=PG", "display_name": "ritchie46", "link": "https://stackoverflow.com/users/6717054/ritchie46"}, "is_accepted": true, "score": 15, "last_activity_date": 1721473972, "last_edit_date": 1721473972, "creation_date": 1647425636, "answer_id": 71495211, "question_id": 71486019, "content_license": "CC BY-SA 4.0", "body": "<p>Polars doesn't allow much mutation and favors pure data handling. Meaning that you create a new <code>DataFrame</code> instead of modifying an existing one.</p>\n<p>So it helps to think of the data you want to keep instead of the row you want to remove.</p>\n<p>Below I have written an example that keeps all data except for the 2nd row. Note that the <code>slice</code> will be the fastest of the two and will have zero data copy.</p>\n<pre class=\"lang-py prettyprint-override\"><code>df = pl.DataFrame({\n    &quot;a&quot;: [1, 2, 3],\n    &quot;b&quot;: [True, False, None]\n}).with_row_index()\n\nprint(df)\n\n# filter on condition\ndf_a = df.filter(pl.col(&quot;index&quot;) != 1)\n\n# stack two slices\ndf_b = df[:1].vstack(df[2:])\n\n# or via explicit slice syntax\n# df_b = df.slice(0, 1).vstack(df.slice(2, -1))\n\nassert df_a.equals(df_b)\n\nprint(df_a)\n</code></pre>\n<h2>Outputs:</h2>\n<pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 index \u2506 a   \u2506 b     \u2502\n\u2502 ---   \u2506 --- \u2506 ---   \u2502\n\u2502 u32   \u2506 i64 \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0     \u2506 1   \u2506 true  \u2502\n\u2502 1     \u2506 2   \u2506 false \u2502\n\u2502 2     \u2506 3   \u2506 null  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 index \u2506 a   \u2506 b    \u2502\n\u2502 ---   \u2506 --- \u2506 ---  \u2502\n\u2502 u32   \u2506 i64 \u2506 bool \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0     \u2506 1   \u2506 true \u2502\n\u2502 2     \u2506 3   \u2506 null \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n</code></pre>\n"}, {"owner": {"account_id": 22209998, "reputation": 466, "user_id": 16449363, "user_type": "registered", "profile_image": "https://www.gravatar.com/avatar/488d04571a56cce6f6330ecda06ccb3c?s=256&d=identicon&r=PG", "display_name": "ghuls", "link": "https://stackoverflow.com/users/16449363/ghuls"}, "is_accepted": true, "score": 15, "last_activity_date": 1720377868, "last_edit_date": 1720377868, "creation_date": 1654166243, "answer_id": 72474838, "question_id": 72474673, "content_license": "CC BY-SA 4.0", "body": "<p>Use <a href=\"https://docs.pola.rs/api/python/dev/reference/dataframe/api/polars.DataFrame.with_row_index.html\" rel=\"nofollow noreferrer\"><code>with_row_index()</code></a>:</p>\n<pre class=\"lang-py prettyprint-override\"><code>df = pl.DataFrame([pl.Series(&quot;a&quot;, [5, 9, 6]), pl.Series(&quot;b&quot;, [8, 3, 4])])\n</code></pre>\n<pre class=\"lang-py prettyprint-override\"><code>In [20]: df.with_row_index()\nOut[20]: \nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 index  \u2506 a   \u2506 b   \u2502\n\u2502 ---    \u2506 --- \u2506 --- \u2502\n\u2502 u32    \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0      \u2506 5   \u2506 8   \u2502\n\u2502 1      \u2506 9   \u2506 3   \u2502\n\u2502 2      \u2506 6   \u2506 4   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<pre class=\"lang-py prettyprint-override\"><code># Start from 1 instead of 0.\nIn [21]: df.with_row_index(offset=1)\nOut[21]: \nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 index  \u2506 a   \u2506 b   \u2502\n\u2502 ---    \u2506 --- \u2506 --- \u2502\n\u2502 u32    \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1      \u2506 5   \u2506 8   \u2502\n\u2502 2      \u2506 9   \u2506 3   \u2502\n\u2502 3      \u2506 6   \u2506 4   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n<pre class=\"lang-py prettyprint-override\"><code># Start from 1 and call column &quot;my_index&quot;.\nIn [22]: df.with_row_index(name=&quot;my_index&quot;, offset=1)\nOut[22]: \nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 my_index \u2506 a   \u2506 b   \u2502\n\u2502 ---      \u2506 --- \u2506 --- \u2502\n\u2502 u32      \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1        \u2506 5   \u2506 8   \u2502\n\u2502 2        \u2506 9   \u2506 3   \u2502\n\u2502 3        \u2506 6   \u2506 4   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n"}], "has_more": true, "quota_max": 300, "quota_remaining": 298}